# 高可用

## 基本思路：主从同步

需要从硬件和软件两个角度来考虑。硬件角度来说，考虑的是易失性内存的处理。从软件角度来说，考虑的是因为软件故障导致的中间

在考虑具体的高可用设计之前，需要先确定系统的整体架构。

一般来讲，主从配置是比较常用的简单的的实现高可用的思路：一个主节点负责上层业务的处理、元数据操作，一个或多个从节点作为该主节点的备份，按照一定的规则进行主从复制。

若主节点挂掉，由于从节点具有和主节点等同（若主从是实时同步的）或稍旧的（若主从不是实时同步的）数据，无论是否与主完全同步，（理论上）这时从节点总是可用的，因此此时可以根据一定的规则在从节点中选举一个新的主节点来，代替原来的主节点进行业务请求的处理、元数据的操作。

等到刚刚挂掉的主节点重新上线，则可以按照一定的规则再次加入集群，它可以重新成为主节点，也可以就这样保持为从节点的状态，从而使得整个集群对外始终保持可用状态，业务不中断。

而目前来讲，高可用的处理方法

## 项目中的高可用处理

异常流程的处理是基于正常流程的，需要首先明白正常流程是怎么处理的。需要从整体系统架构（集群组合方式、集群间节点通信方式、HA模式）出发来考虑。

### 整体架构

两个控制器组合放入一个机框中，被称为一个IO组。一个IO组连接一组硬盘，使用iscsi或FC协议向外提供服务。两个或多个控制器组成一个集群。

每个控制器上都具有相同的CPU、内存等硬件配置，也运行相同的软件。

对于软件来说，设计分为agent部分和CSM(集群状态机）两部分。agent为业务部分代码，两个节点可以根据一些配置（如owner划分）具有独立的处理逻辑，而CSM端则负责整个集群的状态管理(配置管理)。

一个IO组是处理请求的一个基本单位（逻辑上，实际上只有一个控制器也是可用的，当然就不具备高可用性）。

对于每一层的逻辑卷，都有一个owner/non-owner的概念。当上层请求下发时，会有一个转发层按照一定的规则，将该请求下发到某个控制器上，这是第一层转发，作为控制器级别的负载均衡。

当到达某一层的时候，该层的逻辑卷有自己的owner，此时会判断是否为Owner，若是则进行元数据的更新，同时会镜像到对端节点，然后等待对端节点返回成功后，再向上层返回，逐层向上返回一直到主机层。

### IO栈

总体来说，

每一层处理方式可能有不同之处，例如



### 集群与节点间通信

首先需要说明节点间的通信方式。

从硬件角度来说，一个IO组中的两个节点是通过NTB进行通信，因此理论上无需考虑网络分区问题（而这个在分布式系统中则是一个很重要的点）。

这里需要特殊说明的是CSM机制。

### 集群的有效性是如何定义的？

根据节点的状态来判断。

节点是否为pending状态、online_nodes数目。

#### 节点状态（节点视图）



#### 节点状态（集群视图）

### pend/unpend事件的发送

因为双控间使用NTB通信，因此可以不考虑网络分区问题。可能只需要相互发送心跳包便可以判断。

### 故障时内存持久化如何实现？

内存管理方式、标记内存页、守护进程下刷，

#### 如何判断需要下刷？

#### 如何下刷？


#### 如何恢复？

### 事务

### 事务写缓存

### 事务读缓存



### 故障场景划分

#### T1恢复



#### T2恢复



#### T3恢复



#### T4恢复



### 通用的处理框架

#### 业务处理与配置处理的结合：UTMD逻辑(quiesce/ack/resume)



#### 业务处理：process tracker机制





## Redis的高可用处理



## Memcached的高可用处理



## RocksDB的高可用处理



## MariaDB的高可用处理



## RAID的高可用处理