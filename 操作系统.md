# 操作系统基础

https://github.com/linuxkerneltravel/website
什么是进程？这是一个最基础的概念，也是近代操作系统中最成功的概念。可以从以下几个角度考虑，理解了进程以及其相关的多个概念，也就可以理解计算机系统的运行方式。

## CPU运行程序的过程

### CPU与内存寻址

### CPU与中断，中断向量表，栈，寄存器

#### 软件中断

##### 缺页中断

#### 硬件中断

##### 键盘中断

## 系统调用：进程的用户地址空间与内核空间

### 为什么要将进程的地址空间划分为用户空间和内核空间？

一方面，内核地址空间由所有用户空间共享，而用户地址空间无权限直接进行访问，而必须通过给定的接口--即系统调用进行访问，这样就可以保护比较接近硬件的操作，如内存访问、I/O设备访问等，由内核态进程实际管理，只通过内核态-用户态的拷贝来实现数据传输。（当然后面还有了mmap的技术，来直接将一段内存映射到用户地址空间，使得用户进程在访问该用户地址空间被mmap过去的地址时，可以直接反应到实际内存中，这样就可以避免内核态与用户态的频繁拷贝，而造成性能低下）。

### 内核态与用户态是针对CPU还是针对进程？



### 进程地址空间

每个进程运行在它私有的地址空间。在用户态下运行的进程设计到私有栈、数据和代码区。当在内核态运行时，进程访问内核的数据和代码区，但使用另外的栈。



### mmap的本质是什么？


## 进程的数据结构

## 进程与文件描述符

当一个进程需要进行I/O操作的时候，会进行write/read系统调用，陷入内核态。针对一个进程的可能打开多个文件描述符，所以该进程的进程表中有一个子表，用来记录打开的文件描述符。
那么对于一个打开的文件，需要哪些信息来描述呢？

1. 文件的状态标识（读、覆盖写、追加写、同步、非阻塞等）
2. 文件的偏移量
3. 指向当前文件v节点表项的指针（Linux使用i节点）

### i-node与v-node

对于一个我们要操作的文件，如何来描述写到哪里了呢？这就需要一个起始地址和一个偏移量。还需要有磁盘的相应位置的指针。
i-node是一个文件的配置信息，包含了文件的所有者、文件长度、指向文件实际数据块在磁盘的位置的指针等。（具体看APUE 4.14章节）

### 进程表、文件表、v节点表

当打开一个文件的时候，进程中的文件描述符fd，文件指针将指向一个文件表，该文件表描述了文件状态标志、当前文件偏移量，同时有一个v节点指针指向一个v节点表/i节点表。而v节点表则包含了v节点信息。
当多个进程共享同一个文件的时候，本质上是多个进程的文件指针指向了同一个文件表，此时便共享了所有的文件状态以及文件偏移量。因此当一个进程做出修改文件的操作的时候，也会对其他进程造成影响。

### 文件描述符的复制：

### 硬链接、软链接与符号链接

硬链接直接指向文件的i-node，且要求链接和文件位于同一文件系统中，只有superuser用户才能创建指向目录的硬链接。
符号链接的引入是为了避开硬链接的一些限制。符号链接对它指向何种对象并无任何文件系统的限制，任何用户都可以创建指向目录的符号链接，一般用于将文件、文件夹移动到其他目录。

#### 符号链接的本质

#### 硬链接的本质

#### 软链接的本质

## 进程与文件系统

## 进程的执行过程

### 进程的三状态模型与五状态模型

## 进程的生命周期：创建、运行、销毁

### 进程的创建

Linux中进程只有fork()一种方法进行创建。fork出来的进程与原进程为父子进程关系（一次调用，两次返回：对父进程，返回子进程的pid,对子进程，返回0。因为一个父进程可以有多个子进程，而一个子进程只能有一个父进程，而0号进程为系统初始进程init的进程号，因此给父进程返回子进程pid，而子进程返回0代表成功，返回-1代表失败是合理的措施），与父进程拥有相同的内存地址空间，共享文件描述符，但子进程只具有针对该部分虚拟内存页的只读权限。只有当子进程想要修改某个内存页时，内核将会对修改区域的那个内存页只做一个副本进行修改。

### 进程的等待与销毁

#### 进程的终止：

进程什么时候会终止呢？与任何时候考虑问题相同，此时我们可以从正常终止和异常终止两个方面来考虑。


#### 僵尸进程问题

首先需要考虑这样一种情况：当一个父进程有多个子进程，子进程被销毁后是否应该通知父进程？若不通知会怎么样？

## 进程与内存

### 进程什么时候实际分配并占用内存地址，什么时候释放？



### 一个进程中的进程地址空间如何和内存联系起来

## 程序的运行过程

### 堆栈：程序运行的基础

##### 函数调用框架

##### 传递参数

##### 保存返回地址

##### 提供局部变量空间

#### 堆栈相关的寄存器

`esp`: 堆栈指针（stack pointer)

`ebp`: 基址指针（base pointer)。 在C语言中用作记录当前函数的调用基址。注意，是“当前”函数，这也意味着若有多个函数嵌套调用的话，每个函数的`ebp`也是不一样的。这是个堆叠起来的框架。

#### 堆栈操作：

push: 栈顶地址减少4个字节（32位），并将内容写入

pop：栈顶地址增加4个字节（32位）

### 其他关键寄存器：

`cs:ip`： 总是指向下一条的指令地址。由于函数执行不只有顺序执行一种，还可能有循环、跳转、返回等操作，因此抽象出来以下几种操作：

· 顺序执行： 总是指向地址连续的下一条指令；

· 跳转/分支：将当前`cs:eip`的值压入栈顶，`cs:eip`指向被调用函数的入口地址；

· `call`: 将当前`cs:ip`的值压入栈顶，`cs:ip`指向被调用函数的入口地址；

· `ret`: 从栈顶弹出原来保存在这里的`cs:ip`值，放入`cs:eip`中。

·  发生中断时，不仅将`cs:eip`压栈，还做了一些其他的操作

### 函数调用堆栈的工作机制

当调用call target，来进行函数调用时，基本分为以下几步：

1. 建立被调用者函数的堆栈框架。此时会先让`cs:eip`原来的值指向call的下一条指令，该值被保存到栈顶，然后`cs:eip`的值指向被调用函数的入口地址。
2. 执行被调用者函数体
3. 拆除被调用者函数的堆栈框架
4. ret， 将地址恢复到eip中



### 栈帧：

每个函数调用者都有一个栈帧。（存放到哪里？）
栈用来传递过程参数、存储返回信息、保存寄存器供以后恢复用，以及用于本地存储。为单个过程分配的那部分栈被称为栈帧(stack frame)。调用者调用过程时，被调用者的参数放在调用者的栈帧中，调用者的返回地址被压入栈中，行程调用者栈帧的末尾，返回地址就是当被调用程序返回时应该继续执行的地方。被调用程序也用栈来保存其他不能存放在寄存器中的局部变量（因为寄存器不够存放所有的局部变量
有些局部变量时数组或结构，因此必须通过数组和结构引用来访问、要对一个局部变量使用地址操作符&，必须能够为他产生一个地址。
而此处的被调用者也会使用一个栈帧来存放它调用其他的过程的参数。
栈向低地址增长，栈指针esp指向栈顶元素，可以通过push 和pop将数据存入栈中或从栈中取出。使用帧指针ebp来指向当前调用的栈帧的栈底。
call指令的效果是将返回地址入栈，并跳转到被调用过程的起始处。返回地址是紧跟在程序中call后面的那条指令的地址。这样当被调用过程返回时，执行会从此继续，ret指令从栈中弹出地址，并跳转到那个位置。要正确使用这条指令，就需要使栈准备好，栈指针要指向前面call指令存储返回地址的位置。

## 进程与内存的缺页中断

### 页面置换算法

#### FIFO

#### LRU

#### LFU


## 数组与指针的本质

参考《深入理解计算机系统》 p152
都是转换为地址计算，x + k*i，其中x为起始位置，k为每个对象的长度，i为索引。
指针比较特殊的一点在于他是使用一个指针变量来保存一个地址，通过这个地址来找到另一个变量。


## 进程间通信

### 为什么需要特意考虑进程间通信？

每个用户态进程都有独立的进程地址空间，不同的用户态进程不能直接相互访问。这样设计是为了保护在进程运行过程中的内存访问不受相互干扰。只能通过一个公共的区域（如内核地址空间、外部相同文件等）来实现。

### 进程间通信的本质是什么？

#### 内核态

首先需要讲用户态与内核态。
在设计操作系统的时候，为什么需要划分内核态与用户态呢？内核态和用户态的本质区别是什么？
操作系统是一个庞大的系统，它涉及到了CPU、寄存器、内存、外部硬盘以及一些其他的I/O设备等硬件，与硬件之上的软件的相互协同作用，而对于这些硬件设备的直接访问是通用的需求，也是底层的、不安全的操作，因此抽象出来内核态的话，一方面可以避免程序员重复造轮子，一方面可以有一些保护，即权限划分。一个用户态的进程只拥有该进程的地址空间内的权限，而不直接进行修改。

### 管道

### 有名管道FIFO

### 共享内存区



## 线程与进程的不同

线程开销小的本质是什么，为什么可以独立拥有自己的栈，而共享文件描述符、代码区等？

#### 读写锁、互斥锁、自旋锁的本质

一个进程中的所有线程都共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为他们可以访问同一存储区，因此各线程在访问共享数据的时候需要采取一些同步措施来避免数据不一致。

### 线程的同步与互斥

#### 



## 内存管理

对于一个用户态的进程来说，都有一个独立的逻辑地址空间，在初始状态的时候没有与物理内存建立映射关系，即实际上是空的。一开始会将磁盘中的程序加载入内存，同时建立逻辑地址与物理地址之间的关系。程序代码转换结束之后，程序计数器便会按照进程地址空间的代码区的逻辑地址向下运行。



### 需求分析

1. 分配指定字节数的内存区域
2. 分配指定数量指定字节长度的对象分配内存空间
3. 修改之前已经分配的内存区域的大小。当增加长度时，可能需要将以前分配区的内容移到一个足够大的区域。（新增区域内的初始值不确定）
4. 释放之前申请的内存区域
5. 

### 接口分析alloc/malloc/realloc

大多数实现所分配的存储空间比所需的稍大一些，因为需要存储一些管理信息，例如分配快的长度、指向下一个分配快的指针等。
这很重要，这也是基于分页式的内存管理的一个优势：可以寻找多个不连续的页来共同工作。



一个进程的内存被划分为多个区域：堆栈区、BSS区、全局静态区、堆区。针对不同的区域，内存管理的方式不同。

对于局部变量，内存分配在堆栈区。生命周期在函数体中，该函数完成后，内存会自行释放。

对于全局变量，内存分配在静态变量区。静态变量、字符常量，生命周期为整个程序，不会释放。

对于new出来的对象，内存分配在堆区。生命周期为整个程序，不会自动释放。

类对象实例化时，调用构造函数时申请内存，调用析构函数时释放内存。先调用构造函数的后释放。

### 内存泄漏

只申请内存，而不释放，则会造成该进程占用的存储空间连续增加，则该进程的地址空间长度就会增加，直到不再拥有空闲空间。


## 进程与环境变量

环境变量的本质是什么？
每个进程都有一个指向环境表的指针的指针：`extern char **environ`。
这是个全局变量，所指向的环境表中是一个字符串数组，分别设置了例如`PATH`,`HOME`,`SHELL`,`USER`,`LOGNAME`等环境变量。这样在一个进程运行的时候（`fork()`）就会确定好该进程对应的环境变量。
内核并不看这些环境变量，对其的解释全取决于用户进程。

## 线程

##### 线程等待与唤醒



# 优化程序性能

## 优化程序性能，需要从哪些角度来考虑？

1. 选择一组适当的算法和数据结构
2. 编写出编译器能够有效优化以转换成高效可执行的源代码
   1. 这也意味着我们需要理解编译器的能力和局限性。
   2. 消除不必要的函数调用、条件测试和内存引用
   3. 用内联函数替换优化函数调用

## RAID重构性能优化

详见Linux内核，RAID章节部分。

