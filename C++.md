# C++

## 值传递与引用传递

值传递是传递一个值的拷贝，在函数内部改变该值不会影响原来的值。传引用是传了一个地址，也可以理解为将形参和实参绑定起来，在函数内部改变该值会影响原来的值，因为是对同一个地址的值进行操作。

## this指针的本质

C++中的this指针是个隐式参数，是个常量指针，是个保留字符。它指向调用的那个类的对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化this指针。
每个对象都有一个this指针。
例如class Human wang(); 

```c++
wang.say();
```

在如此调用的时候，编译器会将wang的地址传递给say的隐式形参this，可以等价地认为编译器将该调用重写成了如下的形式：
`Human::say(&wang)`
其中，调用Human的say成员时传入了wang的地址。
在成员函数内部，我们可以直接使用调用该函数的对象成员，而无需 通过成员访问运算符来做到这一点，因为this指的正是这个对象。任何对类成员的直接访问都被看做this的隐式引用。也就是说，当wang使用name的时候，它隐式地使用this指向的成员，就像我们书写了this->name一样。

### this指针有什么用处

[this指针作用](https://www.cnblogs.com/xiaolincoding/p/11954905.html)

this实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参 传递给this。不过这个this形参是隐式的，并不出现在代码中，而是在编译阶段由编译器将其添加到参数列表中。作用就是指向函数所指作用的对象。可以对比C++(通过隐含的this指针）和C的实现（通过形参传入该对象的地址）来对比分析。
可以直接使用this指针来指向该函数作用的对象的指针。

在编译完成之后，会失去对象与成员的关系，因此需要一个指针来告诉当前成员函数是执行在哪个对象上的。（待细化）

静态成员不能使用this指针。因为静态成员是存储在静态存储区的，该变量的声明周期在整个进程的声明周期中，相当于一个共享的变量，而不是一个成员的变量。

### this指针的意义？

this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。



this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。



在《[C++函数编译原理和成员函数的实现](http://c.biancheng.net/view/vip_2220.html)》一节中讲到，成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。

## 构造函数与拷贝构造函数

为什么需要拷贝构造函数
当一个类实例化一个对象的时候，会调用构造函数。而想要实例化另一个对象，且想要拷贝刚实例化好的，可能已经经历一些逻辑改了值的成员变量值，那么就可以拷贝之前那个实例对象来实现。
此时就需要考虑一般成员和动态成员。对于一般成员，直接复制即可，而对于一些动态成员，则需要额外的内存申请、释放过程。这样的话就需要一个独立的、可控的接口来实现。因此就有了拷贝构造函数。

## struct与class的异同

除了默认访问权限，struct中默认为public,class为private，其他都相同。


## 友元：一种放开权限的不安全方法

### 为什么要有友元：

一般来说，对于一个类的成员变量，若被定义为private/protected，则类外的函数是无法访问的。若想这样实现，就可以使用friend修饰该类外的函数，以实现外部访问内部变量的效果。
但友元函数并不是成员函数。

## 封装的好处

封装可以确保用户代码不会无意间破坏封装对象的状态。
被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。
一般来说，将数据成员定义为private的话，类的作者就可以比较随意地修改数据了。当实现部分改变时，我们只需检查类代码本身以确认这次改变有什么影响--只要类的接口不变，用户代码就无需改变（这也是定义外部接口很重要的原因：尽量避免接口变动）。而若数据是public的，则该值被改变的可能性就扩大到了类作者和用户，定位问题时就需要排查更多东西。
另一个好处在于，可以防止于是用户的原因造成数据被破坏。

## 运算符重载

运算符重载可以允许以灵活的方式处理自定义的类的一些操作，如+-*/。
但一些内置的运算符是不允许重载的，这些不能被重载的运算符被定义为具有固定功能的运算符，不能因为类的不同而自定义，例如：

```c
.：成员访问运算符
.*, ->*：成员指针访问运算符
::：域运算符
sizeof：长度运算符
?:：条件运算符
#： 预处理符号
```

## 静态的本质

### 什么是静态，为什么这么设计

静态的意思是，它是静态的，是“一直存在的”，不是针对某个具体的对象的，是“共享的”。

静态`static`是相对于动态来说的。在类与对象的设计思想中，一切都是对象，即对于一个方法来说，它是属于某个类的某个实例化出来的对象的，它自己私有一套成员变量数据，不同对象之间不能直接访问，倒是可以通过一些公有接口来访问。

这可以从多个角度来考虑。
从进程地址空间的角度来说，管理静态变量的地址空间范围被单独定义为静态变量区。这与堆栈区不同。
对于全局对象、静态对象以及分配在栈区域的对象，对他们的内存分配在编译阶段就完成了。而对于分配在堆区域内的对象，他们的分配是程序运行阶段完成的。

### C与C++中的静态

C中，有静态局部变量和静态全局变量两种。静态局部变量在函数内定义，生存期为整个源程序，但作用域与局部变量相同，只能在定义该变量的函数中使用。函数退出后便不可访问，但值仍然保留原来的值，等再次进入后还可以获得原来的值。

C的静态全局变量与全局变量相似，生存期为整个源程序，而作用域略微不同：全局变量可以在整个工程的任何源代码文件中使用，而静态全局变量只能当前源代码文件中使用。

## new一个对象的时候发生了什么？

[参考](https://zhuanlan.zhihu.com/p/87760996)

### new的执行过程 

（1）通过operator new申请内存
（2）使用placement new调用构造函数（简单类型忽略此步）调用代码区的构造函数，并传递刚才开辟的内存空间this指针给该函数。有初始化列表的先初始化列表，再执行构造函数中的函数体赋值操作。
（3）返回内存指针

### new的三种形态：new operator, operator new, placement new

#### （1）new operator

上面所说的new就是new operator，共有三个步骤组成（申请内存，调用构造函数，返回内存指针），对于申请内存步骤是通过运算符new(operator new)完成的，对于调用什么构造函数，可以由placement new决定。

#### （2）operator new

像普通运算符一样可以被重载，operator new会去申请内存，申请失败的时候会调用new_handler处理，这是一个循环的过程，如果new_handler不抛出异常，会一直循环申请内存，直到成功。
重载运算符new

```c++
class Test{
public:
  void* operator new(size_t size){ ... }
};
```

operator new默认会去申请内存，成功了会返回内存地址，失败了会调用new_handler，然后再去申请内存，一直循环。所以operator new要返回，必须满足一下条件：
A. 在程序启动的时候预留一部分内存，在new_handler里释放这部分内存，使得operator new能成功分配到内存
B.抛出bad_alloc异常
C.直接退出程序(abort, exit)
D.设置新的new_handler处理函数，set_new_handler(0)取消当前处理函数，默认抛出bad_alloc异常

#### （3）placement new

用于定位构造函数，在指定的内存地址上用指定类型的构造函数构造对象。
例如：`new(ptr) Test("hello");// ptr->Test::Test("hello");`

我们可以利用malloc+placement new来构建自己的内存管理模块，创建对象时，通过malloc申请一个内存块，然后调用placement new来完成对象的初始化；释放对象时，首先调用对象的析构函数，然后通过free释放空间.

### new和malloc的异同？

1. new失败时会调用new_handler处理函数，malloc不会，失败时返回null；
2. new能通过placement new自动调用对象的构造函数，malloc不会。
3. new出来的东西是带类型的，即被强转为一个类型的指针。malloc的是void*，需要强制转换。
4. new是C++运算符，malloc是C标准库函数。

### delete的执行过程

1. 调用析构函数
2. 释放内存

### delete和free的异同

1. delete能自动调用对象的析构函数，free不会。
2. delete是C++运算符，free是C的标准库函数。

## 多态的本质

### 多态是什么，有什么好处？

父类的一个指针，可以有多种执行状态（父类的指针调用子类的函数）。

多态是一种这样的思想，虚函数是实现这个思想的语法基础。

[C++幕后故事（四）-- 虚函数的魅力](https://zhuanlan.zhihu.com/p/82138881)

### 1.虚函数指针和虚表在哪里？

**虚表**

- 若对象有虚函数，对象空间最开始 4Byte(32Bit目标平台)或 8Byte(64bit目标平台)内容是虚表(虚函数列表)的首地址，叫虚指针
- 在实例化对象时，编译器检测到虚函数(virtual修饰的成员函数)时，会将虚函数的地址放到虚表(类似于一个存放函数指针的数组)中
- 当实例化子类时，检测到有虚函数的重写，编译器会用子类重写的虚函数地址覆盖掉之前父类的虚函数地址，当调用虚函数时，检测到函数是虚函数就会从虚表中找对应的位置调用，若子类没有重写，虚表中的虚函数地址就还是父类的，若子类中有重写，虚表记录的就是子类重写的虚函数地址，即实现了父类的指针调用子类的函数
- 虚表中先记录父类中的虚函数地址，接着记录子类中虚函数地址(若子类重写父类的虚函数则是覆盖)
- 最后虚表还有一个尾值是 0

### 2.我们如何手动调用虚函数？

### 3.为什么只有在子类以父类的引用或者指针的形式才能出现多态？

- 在单一 class 中实现虚函数意义并不大，虚函数主要是为了实现子类函数重写父类函数的作用
- 要实现多态，通常父类中的虚函数与子类中的函数的返回值类型、函数名和参数列表必须都相同的，但是在协变的情况下返回值类型可以不一样，协变即虚函数的返回值类型为所在类的指针或引用

### 4.虚函数的调用为什么效率相比普通的成员函数较低？又具体低了多少？

- 子类重写的函数默认是虚函数，也可以显式的加上 virtual，也可以不加
- 虚函数不能是内联函数，加上 inline 是没有效果的
- 构造函数不能是虚函数
- 析构函数可以是虚函数(在多态中应写虚析构)

### 5.为什么构造函数和析构函数尽量不要调用虚函数？

**虚析构**

- 在多态中，如果释放父类指针(指向子类的父类指针)，只会调用父类的析构函数，将父类的析构函数声明为虚函数(虚析构，加 virtual 修饰的析构函数)，就会先调用子类的析构函数再调用父类的析构函数，所以在多态中，要用虚析构
- 父类的析构函数加了 virtual 修饰，delete 会调用子类和父类的析构函数，子类可以显式的加 virtual ，也可以不加， 默认是有的 virtual
- 还有一点需要注意的，delete 谁的指针就会调用谁的析构函数

### 6.纯虚函数到底是什么？为什么禁止我调用？有什么办法可以绕编译器

**纯虚函数**

- virtual void fun() = 0; // 这是纯虚函数的形式
- 纯虚函数可以没有函数实现，有纯虚函数的类不能实例化对象，继承有纯虚函数的父类的子类必须在子类中实现它，子类才能实例化对象，如果不在子类中实现它，子类也不能实例化对象
- 抽象类，有纯虚函数的类就是抽象类
- 接口类，除数据成员和构造函数外，其余全是纯虚函数的类，子类继承接口类必须实现全部的纯虚函数
- 构造函数不可以是纯虚函数


## 模板

### 为什么发明模板？

起因在于想要针对不同类型的参数，想要实现相同的功能。

### 函数模板

按照这种需求，可以考虑到的方法有两种。

一种是使用宏来实现。将类型也作为一个宏变量，直接在编译阶段无脑替换过去，既可以简单地实现类型的参数化。这种方法的好处在于简单、代码复用，适合所有类型。缺点是缺少类型检查。

一种是使用函数重载，相同函数名而形参不同。这样做的好处在于这是真正的函数调用，C++编译器会进行类型检查。缺点是需要根据类型重新定义函数，无法实现代码复用。若有100种类型，需要定义这100中重载函数。

在以上两种已有的技术的处理条件下，C++发明了一种模板方法，可以使用不同的类型进行调用的特殊函数，关键在于类型的参数化。

```c++
//示例
#include <iostream>
using namespace std;
template <typename T>
void Swap(T& a,T &b )
{
    T t = a;
    a = b;
    b = t;
}
int main()
{
    int ia = 10; int ib = 20;
    Swap(ia,ib); //Swap<int>(ia,ib);
    cout<<ia<<ib<<endl;
    double da = 10, db = 20;
    Swap(da,db); //Swap<double>(da,db);
    cout<<da<<db<<endl;
    string sa ="china"; string sb = "America";
    Swap(sa,sb);
    cout<<sa<<sb<<endl;
    return 0;
}
```

### 函数模板的本质

模板这个操作是如何实现的，以至于既拥有了参数可替换的优势，又可以进行类型检查的优势？

C++编译器会从函数模板具体类型产生不同的函数，然后进行两次编译。一次是函数模板代码进行编译，一次是参数替换过去的函数代码进行编译。

```c++
#include <iostream>
using namespace std;
template <typename T>
void Swap(T& a, T& b){
    T c = a;
    a = b;
    b = c;
}

class Test{
};

typedef void (*pFuncInt)(int&, int&);
typedef void (*pFuncDouble)(double&, double&);
typedef void (*pFuncTest)(Test&, Test&);

int main(int argc, char *argv[]){
    pFuncInt pi = Swap;//Swap<int>
    printf("0x%x\n", pi);
    pFuncDouble pd = Swap;//Swap<double>
    printf("0x%x\n", pd);
    pFuncTest pt = Swap;//Swap<Test>
    printf("0x%x\n", pt);
    return 0;
}
```



### 类模板

### [模板的本质](https://blog.51cto.com/9291927/2164583)

### 优劣分析

优点:

\1. 灵活性, 可重用性和可扩展性;

\2. 可以大大减少开发时间，模板可以把用同一个算法去适用于不同类型数据，在编译时确定具体的数据类型;

\3. 模版模拟多态要比C++类继承实现多态效率要高, 无虚函数, 无继承;

 

缺点:

\1. 易读性比较不好，调试比较困难;

\2. 模板的数据类型只能在编译时才能被确定;

\3. 所有用基于模板算法的实现必须包含在整个设计的.h头文件中, 当工程比较大的时候, 编译时间较长;